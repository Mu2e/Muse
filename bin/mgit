#! /bin/bash
#
# script to do partial checkout of the Offline git repo
# See https://mu2ewiki.fnal.gov/wiki/GitPartialCheckout
#

#
# init the partial checkout directory
#
mg_usage() {
echo "

   mgit command <args>

     A script to help with partial checkout of Offline repo.  It is necessary 
  to use \"muse link\" to link to the backing build.  Then use \"mgit init\"
  to start the partial checkout area.  
     When building only part of a repo locally, it is important to always be 
  aware of how compatable the linked release is with your local modification.
  See the wiki for more information.

  mgit init [user]
     start partial checkout.  This step will create the Mu2e remote, 
     and your personal fork as a remote if you provide the username argument.
  mgit status
     See the status of the build area, including dependency issues
  mgit add PACKAGE [PACKAGE]
     add the PACKAGE subdirectory
  mgit rm PACKAGE [PACKAGE]
     remove the PACKAGE subdirectory (requires \"muse build -c\")
  mgit quit
     revert to non-sparse checkout (requires re-setup)
  mgit help
     print this help

"

}

#
# get current branch
#
mg_branch() {
    git status -b | awk '{if(NR==1) print $3}'
}

#
# check if there are diffs or untracked in local checkout
# if there is an argument, then check only that directory
#
mg_test_clean() {
    local DD=$1
    local ret=""
    # diffs
    local test1=$( git diff --shortstat $DD )
    [ -n "$test1" ] && ret="diffs"
    # untracked
    local test2=$( git ls-files --others --exclude-standard $DD )
    if [ -n "$test2" ]; then
	[ -n "$ret" ] && ret="${ret},"
	ret="${ret}untracked files"
    fi

    # if we are checking only one dir, then 
    # return now, before looking for unpushed commits
    if [ -n "$DD" ]; then
	echo $ret
	return
    fi

    # check for unpushed commits
    local branch=$( mg_branch )
    local test3=$( git diff --shortstat origin/${branch}..HEAD )
    #echo $branch $test3 > s.txt
    if [ -n "$test3" ]; then
	[ -n "$ret" ] && ret="${ret},"
	ret="${ret}unpushed commits"
    fi
    echo $ret
}

#
# init the partial checkout directory
# use cases:
# 1 no existing Offline
# 2 Offline exists, in full checkout
#   a) repo requested
#   b) no repo requested, has stored backing repo
#   c) no repo requested, no stored
# 3 Offline exists in partial checkout
#   a) repo requested, same as current
#   b) repo requested, not same as current
#   c) no repo requested
#
mg_init() {
    local USERNAME="$1"

    if [ ! -d Offline ]; then
	git init Offline || exit 1
    fi

    cd Offline
    TEST=$( git remote -v | grep fetch | awk '{if($1=="mu2e") print $1}' )
    if [ -z "$TEST" ]; then
	git remote add mu2e https://github.com/Mu2e/Offline || exit 1
    fi

    git fetch mu2e || exit 1

    if [ -n "$USERNAME" ]; then
	TEST=$( git remote -v | grep fetch | awk '{if($1=="origin") print $1}' )
	if [ -z "$TEST" ]; then
	    git remote add origin git@github.com:${USERNAME}/Offline || exit 1
	fi
	git fetch origin || exit 1
    fi

    # save variables to .git/config
    git config core.sparsecheckout true
    #git config mu2e.baserelease $base_repo

    # what to check out initially
    echo "/.muse" >  .git/info/sparse-checkout
    echo "/.gitignore" >>  .git/info/sparse-checkout
#    echo "/site_scons" >>  .git/info/sparse-checkout

    git checkout -b mgit_work mu2e/master || exit 1
    git read-tree --reset -u HEAD || exit 1

    return 0

}



#
# check the local rel against the base
#
mg_status() {

    echo " status function not implemented yet"

#    local branch=$( mg_branch )
#    echo "mgit - fetching..."
#    git fetch
#
#    local base_repo=$( git config mu2e.baserelease )
#    if [ -z $base_repo  ]; then
#	echo "mgit - WARNING - did not detect a base release, can't check much - "
#	echo "         you probably want to run mgit init?"
#    else
#	local hash=$( git rev-parse origin/$branch | cut -c 1-8 )
#	cwd=$PWD
#	cd $base_repo
#	local basehash=$( git rev-parse origin/$branch | cut -c 1-8 )
#	cd $cwd
#	if [ "$basehash" != "$hash"  ]; then
#	    echo "mgit - WARNING - your base release is at $basehash "
#	    "    but the head  of branch $branch is at $hash"
#	    "    your working area may be fatally out of sync with your base"
#	    
#	fi
#
#	local depfile=$base_repo/../deps.txt
#	dirs=$(cat $depfile | grep HDR | awk '{print $2}')
#	local deps=""
#	local ndir=0
#	for dir in $dirs
#	do
#	    if [ -d $dir ]; then
#		
#		# see what depends on this checked-out dir
#		while read line
#		do
#		    if [[ "$line" =~ "HDR" ]]; then
#			local temp=$( echo $line | awk '{x=0; for(i=3; i<=NF; i++) {if($i=="'$dir'") x=1;} if(x==1) print $2; }' )
#		    fi
#		    if [ "$temp" != "$dir" ]; then
#			deps="$deps $temp"
#		    fi
#		done < $depfile
#
#		deps=$( echo $deps $temp | tr " " "\n" | sort -u  )
#		ndir=$(($ndir + 1))
#	    fi
#	done
#	if [ -z "$deps"  ]; then
#	    echo "mgit - did not find any directories dependent on your $ndir checked-out directories"	    
#	else
#	    echo "mgit - WARNING - the following set of Offline directories"
#	    echo " depend on your local checked-out header files. If you modify"
#	    echo " a local header file, the base release will be inconsistent."
#	    echo " You can \"mgit add\" these to your local area,"
#	    echo " \"mgit quit\" partial checkout, or analyze and take your chances... "
#	    echo " " 
#	    echo $deps
#	    echo " " 
#	fi
#    fi
#
#    git status

}


#
# add packages
#
mg_add() {
    local BRANCH=$( mg_branch )

    for DD in $@
    do
	SDD="/$DD"
	if [[ "$DD" =~ "/" ]]; then
	    echo "mgit - add target connot contain '/' - skipping"
	elif grep -q $SDD .git/info/sparse-checkout ; then
	    echo "mgit - directory $DD already in checkout list"
	else
	    echo $SDD >>  .git/info/sparse-checkout
	    echo "mgit - directory $DD added"
	fi
    done
    
    git checkout $BRANCH

}

#
# remove packages
#
mg_rm() {

    local BRANCH=$( mg_branch )

    for DD in $@
    do
	SDD="/$DD"
	if grep -q $SDD .git/info/sparse-checkout ; then
	    if [ -d $DD ]; then
		local test=$( mg_test_clean $DD )
		if [ -n "$test" ]; then
		    echo "mgit - directory $DD has local changes"
		    echo "          - stash or reset and try again"
		    continue
		fi

		# in order for the dir to go away, all 
		# untracked files must be gone
		#find $DD -name "*.os" -delete

	    else
		echo "mgit - directory $DD was not found locally"
	    fi

	    sed -i '/\/'${DD}'/d' .git/info/sparse-checkout
	    echo "mgit - directory $DD removed from checkout list"
	else
	    echo "mgit - directory $DD was not in checkout list"
	fi
    done

    # this acts on the change
    git checkout $BRANCH

    echo "mgit - *** use \"muse build -c\" to remove build products from removed local source code ***"

}

#
# undo the partial checkout
#
mg_quit() {

    local clean=$( mg_test_clean )
    if [ -n "$clean" ]; then
	echo "ERROR mgit - you are in a working dir with $clean"
	echo "     make your working area clean before running mgit init"
	return 1
    fi

    echo "mgit - turning off partial checkout"
    echo "*" > .git/info/sparse-checkout
    git config core.sparsecheckout true
    git read-tree --reset -u HEAD

    rm .git/info/sparse-checkout
    git config core.sparsecheckout false
    # leave the repo defined in case we want to go back to it
    #git config --unset mu2e.baserelease

    echo "mgit - *** you must re-login, setup, and \"scons -c\" to correct your paths ***"
}



#
# main
#

if [ -z "$MU2E" ]; then
    echo "ERROR mgit - mu2e is not setup"
    exit 1
fi


CI_BASE=/cvmfs/mu2e-development.opensciencegrid.org/museCIBuild

command="$1"
shift

case "$command" in
    init)
	mg_init $@
	;;
    add)
	mg_add $@
	;;
    rm)
	mg_rm $@
	;;
    quit)
	mg_quit $@
	;;
    status)
	mg_status $@
	;;
    help)
	mg_usage $@
	;;
    *)
	echo "ERROR mgit - unknown command: $command, try mgit help"
	;;
esac


